<html>
<head>

<link rel="stylesheet" href="css/main.css">
<script type="text/javascript" src="js/config.js"></script>

<script>
	const versionStr = "2.0.1";
	console.log(`Map overlay V${versionStr} initialized`);
</script>

<script>
	var mapInfo =
	{
		MAP_TIER: -1,
		MAP_STATUS: -1,
		MAP_MODE: "-1",
		MAP_NAME: "-1"
	};

	var timeInfo =
	{
		WR_TP_TIME: -1,
		WR_TP_PLAYER: "",
		WR_PRO_TIME: -1,
		WR_PRO_PLAYER: "",
		PB_TP_TIME: -1,
		PB_PRO_TIME: -1
	};
	
	const cacheHandler =
	{
		set: function(target, prop, value)
		{
			Reflect.set(target, prop, value);
			OnValue(target, prop, value);
		}
	}
	
	var mapInfo = new Proxy(mapInfo, cacheHandler);
	var timeInfo = new Proxy(timeInfo, cacheHandler);

	var lastTimestamp = -1;
	var heartbeatTimer = null;
	var ws = new WebSocket(wsUrl, (typeof protocol !== "undefined" && protocol != null) ? protocol : []);
	
	ws.onopen = () => ws.send("");
	ws.onmessage = (evt) =>
	{
		clearTimeout(heartbeatTimer);
		document.getElementById("overlay").style.opacity = 1;
		heartbeatTimer = setTimeout(noHeartbeat, (heartbeatInterval + 1) * 1000);
		
		var obj = JSON.parse(evt.data);
		if (!obj.hasOwnProperty("map")) return;
		if (!obj.map.hasOwnProperty("name")) return;

		var timestamp = obj.provider.timestamp;
		var modeName = ClanToShortModeSafe(obj.player.clan == null ? "KZT" : obj.player.clan);
		var mapName = obj.map.name.includes("/") ? obj.map.name.split("/")[2] : obj.map.name;

		var mapChanged = (mapInfo.MAP_NAME !== mapName);
		var validMapPrefix = validMaps.includes(mapName.split("_")[0]);
		var heartbeatUpdate = (timestamp - lastTimestamp) >= heartbeatInterval;
		
		if (mapChanged)
		{
			mapInfo.MAP_TIER = -1;
			mapInfo.MAP_MODE = "-1";
			mapInfo.MAP_STATUS = -1;
			mapInfo.MAP_NAME = mapName;
			
			timeInfo.WR_TP_TIME = -1;
			timeInfo.WR_TP_PLAYER = "";
			timeInfo.WR_PRO_TIME = -1;
			timeInfo.WR_PRO_PLAYER = "";
			timeInfo.PB_TP_TIME = -1;
			timeInfo.PB_PRO_TIME = -1;
			
			if (validMapPrefix)
			{
				SendAndCallFunc(`${apiUrl}/maps/name/${mapInfo.MAP_NAME}`, OnResponse, "MAP_INFO");
			}
		}
		
		var modeChanged = (mapInfo.MAP_MODE !== modeName);

		if (modeChanged && validMapPrefix)
		{
			mapInfo.MAP_MODE = modeName;
			
			timeInfo.WR_TP_TIME = -1;
			timeInfo.WR_TP_PLAYER = "";
			timeInfo.WR_PRO_TIME = -1;
			timeInfo.WR_PRO_PLAYER = "";
			timeInfo.PB_TP_TIME = -1;
			timeInfo.PB_PRO_TIME = -1;
		}

		if (heartbeatUpdate && !mapChanged && validMapPrefix && mapInfo.MAP_STATUS == -1)
		{
			SendAndCallFunc(`${apiUrl}/maps/name/${mapInfo.MAP_NAME}`, OnResponse, "MAP_INFO");
		}

		if ((mapChanged || modeChanged || (heartbeatUpdate && mapInfo.MAP_STATUS == 1)) && validMapPrefix)
		{
			lastTimestamp = timestamp;
			
			DebugLog("[I] Update triggered!", "mediumblue");
			DebugLog("=> Heartbeat: " + heartbeatUpdate, "lime");
			DebugLog("=> Map changed: " + mapChanged, "lime");
			DebugLog("=> Mode changed: " + modeChanged, "lime", true);

			var globalMode = ClanToGlobalMode(mapInfo.MAP_MODE);
			var baseRecordUrl = `${apiUrl}/records/top`;
			baseRecordUrl += `?stage=0`;
			baseRecordUrl += `&limit=1`;
			baseRecordUrl += `&tickrate=128`;
			baseRecordUrl += `&map_name=${mapInfo.MAP_NAME}`;
			baseRecordUrl += `&modes_list_string=${globalMode}`;
			
			var TP_TIME_URL = baseRecordUrl + "&has_teleports=true";
			var PRO_TIME_URL = baseRecordUrl + "&has_teleports=false";

			SendAndCallFunc(TP_TIME_URL, OnResponse, "WR_TP_TIME", obj.provider.steamid);
			SendAndCallFunc(PRO_TIME_URL, OnResponse, "WR_PRO_TIME", obj.provider.steamid);
		}
	}
	
	//////////////////// HELPERS /////////////////////////
	
	// TODO: Separate debugging from main functionality
	function DebugLog(buffer, color = "None", printSeparator = false)
	{
		if (!debugMode) return;
	
		if (color == "None" || typeof(buffer) == "object")
		{
			console.log(buffer);
		}
		else
		{
			const styleStr = `color: ${color}`;
			console.log("%c" + buffer, styleStr);
		}
			
		if (printSeparator)
		{
			var size = buffer.length < 18 ? 18 : buffer.length;
			console.log(Array(size + 1).join("-"));
		}
	}
	
	function FormatTime(seconds)
	{
		seconds = parseFloat(seconds).toFixed(2);
		var h = Math.floor(seconds / 3600);
		var m = Math.floor(seconds % 3600 / 60);
		var s = Math.floor(seconds % 3600 % 60);
		var ms = seconds.slice(-3);
		
		var zeroPad = (num) => { return ('000' + num).slice(2 * - 1); }
		var displayString = zeroPad(m) + ":" + zeroPad(s) + "." + zeroPad(ms);
		
		if (h > 0) displayString = zeroPad(h) + ":" + displayString;
		return displayString;
	}
	
	function ClanToShortModeSafe(input)
	{
		switch (input)
		{
			case "KZT":
			case "SKZ":
			case "VNL":
			{
				return input;
			}
			
			default: return "KZT";
		}
	}
	
	function ClanToGlobalMode(input)
	{
		switch (input)
		{
			case "KZT": return "kz_timer";
			case "SKZ": return "kz_simple";
			case "VNL": return "kz_vanilla";
		}
	}
	
	function SetElementText(token, text, css)
	{
		element = document.getElementById(token);
		if (element === null) return;

		const animate = element.textContent !== text;

		if (!animate)
		{
			element.textContent = text;
		}
		else
		{
			element.textContent = text;
			element.classList.add("hide");
			element.classList.remove("show");

			setTimeout(function(element, text)
			{
				element.classList.add("show");
				element.classList.remove("hide");
			}.bind(null, element, text), 1000);
		}

		element.style = css;
	}
	
	function SendAndCallFunc(url, func, resultType, data)
	{
		var http = new XMLHttpRequest();
		http.open("GET", url, true);
		http.send();
		http.onreadystatechange = () => func(http, resultType, url, data);
	}

	///////////////////// LISTENERS //////////////////////
	
	// TODO: Dont attempt to make queries whenever noHeartbeat() happens
	function noHeartbeat()
	{
		document.getElementById("overlay").style.opacity = 0;
	}
	
	function OnValue(target, prop, value)
	{
		// We have some exceptions!
		switch (prop)
		{
			case "WR_TP_TIME":
			case "WR_PRO_TIME":
			{
				if (timeInfo[prop] != -1)
				{
					value = FormatTime(value);
				}
				break;
			}
			
			case "PB_TP_TIME":
			case "PB_PRO_TIME":
			{
				var timeType = "WR" + prop.substring(2);
			
				if (timeInfo[prop] != -1)
				{
					if (timeInfo[timeType] == timeInfo[prop])
					{
						value = -3;
					}
					else
					{
						var wrDiff = value - timeInfo[timeType];
						value = "+" + FormatTime(wrDiff);
					}
				}
				else
				{
					var wrValue = timeInfo[timeType];
					value = wrValue == -1 ? -1 : -2;
				}
				break;
			}
		}

		var css = "";
		var selector = "*";
		var valueTemplate = "{value}";
		
		if (mappings.hasOwnProperty(prop))
		{
			var map = mappings[prop];

			if (map.hasOwnProperty(value))
			{
				selector = value;
			}
			
			if (map.hasOwnProperty(selector))
			{
				valueTemplate = map[selector];
			}

			var cssSelector = selector + ":css";
			if (map.hasOwnProperty(cssSelector))
			{
				css = map[cssSelector];
			}
		}

		DebugLog("[I] Value mapping:", "teal");
		DebugLog("[I] CSS: \"" + css + "\"", "red");
		DebugLog("Prop: " + prop + ` (${selector})`);
		DebugLog("==> \"" + valueTemplate + "\"", "lime");

		value = valueTemplate.replace("{value}", value);
		DebugLog("<== \"" + value + "\"", "lime", true);
		SetElementText(prop, value, css);
	}
	
	function OnResponse(http, resultType, url, steamid)
	{
		if (http.readyState == 4)
		{
			if (http.status == 200)
			{
				var json = JSON.parse(http.responseText);
				OnSuccess(json, resultType, url, steamid);
			}
			else if (http.status == 204)
			{
				OnEmptyResponse(resultType);
			}
		}
	}

	function OnSuccess(data, resultType, url, steamid)
	{
		switch(resultType)
		{
			case "MAP_INFO":
			{
				mapInfo.MAP_TIER = data.difficulty;
				mapInfo.MAP_STATUS = data.validated ? 1 : 0;
				break;
			}
			
			case "WR_TP_TIME":
			case "WR_PRO_TIME":
			case "PB_TP_TIME":
			case "PB_PRO_TIME":
			{
				var timeExists = data[0] != null;
				timeInfo[resultType] = timeExists ? data[0].time : -1;

				if (resultType.substring(0, 2) == "WR")
				{
					const playerProp = resultType.replace("TIME", "PLAYER");
					var playerName = timeExists ? data[0].player_name : "";

					if (playerName.length > 6)
					{
						playerName = playerName.substring(0, 6) + "...";
					}

					timeInfo[playerProp] = playerName;

					const pbUrl = url + "&steamid64=" + steamid;
					SendAndCallFunc(pbUrl, OnResponse, "PB" + resultType.substring(2));
				}
				break;
			}
		}
	}
	
	function OnEmptyResponse(resultType)
	{
		switch (resultType)
		{
			case "MAP_INFO":
			{
				mapInfo.MAP_TIER = -1;
				mapInfo.MAP_STATUS = 0;
			}
		}
	}
</script>
</head>

<body>
<table id="overlay">
	<tr>
		<td id="MAP_ROW">
			<span id="MAP_NAME"></span>
            <span id="MAP_MODE"></span>
            <span id="MAP_TIER"></span>
            <span id="MAP_STATUS"></span>
		</td>
	</tr>
	<tr>
		<td id="TP_ROW">
			<span id="WR_TP_TIME"></span>
			<span id="WR_TP_PLAYER"></span>
			<span id="PB_TP_TIME"></span>
		</td>
	</tr>
	<tr>
		<td id="PRO_ROW">
			<span id="WR_PRO_TIME"></span>
			<span id="WR_PRO_PLAYER"></span>
			<span id="PB_PRO_TIME"></span>
		</td>
	</tr>
</table>
</body>

</html>
